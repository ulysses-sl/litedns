package main

import (
	"github.com/miekg/dns"
	"hash/fnv"
	"net/http"
	"strings"
)

// Unique creates a new slice that are unique based on the comparable key
// generated by asKey function.
func Unique[T any, K comparable](s []T, asKey func(T) K) []T {
	acc := make([]T, 0)
	processed := make(map[K]struct{})
	for _, x := range s {
		k := asKey(x)
		if _, seen := processed[k]; !seen {
			processed[k] = struct{}{}
			acc = append(acc, x)
		}
	}
	return acc
}

// CloneSlice works similarly to slices.Clone(), but the size is explicitly
// allocated exactly the same as the original slice length.
func CloneSlice[S ~[]E, E any](s S) S {
	// Preserve nil in case it matters.
	if s == nil {
		return nil
	}
	c := make(S, 0, len(s))
	return append(c, s...)
}

func HashString(s string) uint64 {
	h := fnv.New64a()
	_, _ = h.Write(AsSlice(s))
	return h.Sum64()
}

func GetBody(c *http.Client, url string) (string, error) {
	resp, err := c.Get(url)
	c.CloseIdleConnections()
	if err != nil {
		return "", err
	}
	if resp.StatusCode != http.StatusOK {
		return "", NewHTTPFailureError("GET", url, resp.StatusCode)
	}
	var respBody string
	if respBody, err = ReadAllString(resp.Body); err != nil {
		return "", err
	}
	return respBody, nil
}

// ParseABPList returns the slice of slices containing individual subdomain
// components, e.g. "||www.google.com^" -> ["www.google.com."]
func ParseABPList(abpFilter string) ([]string, error) {
	abpLines := strings.Split(abpFilter, "\n")
	blockList := make([]string, 0)
	for i, line := range abpLines {
		trimmed := strings.TrimRight(line, " \t")
		if len(trimmed) == 0 { /* empty lines are allowed */
			continue
		}
		if strings.HasPrefix(trimmed, "!") { /* comments */
			continue
		}
		if strings.HasPrefix(trimmed, "[") { /* ABP version */
			if strings.HasSuffix(trimmed, "]") {
				continue
			}
			return nil, NewABPSyntaxError(i+1, line)
		}
		if !strings.HasPrefix(trimmed, "||") {
			return nil, NewABPSyntaxError(i+1, line)
		}
		if !strings.HasSuffix(trimmed, "^") {
			return nil, NewABPSyntaxError(i+1, line)
		}
		blockedDomain := trimmed[2 : len(trimmed)-1]
		if _, ok := dns.IsDomainName(blockedDomain); !ok {
			return nil, NewInvalidDomainNameError(blockedDomain)
		}
		cname := dns.CanonicalName(blockedDomain)
		blockList = append(blockList, cname)
	}
	return blockList, nil
}
